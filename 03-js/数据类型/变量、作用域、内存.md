### 作用域
##### 基本类型
- 基本类型在内存中占据固定大小的空间，因此被保存在栈内存中
- 从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本
- 引用类型的值是对象，保存在堆内存中
- 包含引用类性值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针
- 从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象
- 确定一个值是哪种基本类型可以使用typeof操作符，而确定一个值是哪种引用类型可以使用instanceof操作符

##### 动态的属性
- 基本类型的动态
```
var name = 'xiaoming'
name.age = 27 // 不会报错
console.log(name.age); // undefined
```
- 函数传参，不管是基本类型还是引用类型，传递的都是值
```
function setName(obj) {
    obj.name = 'xiao';
    obj = new Object();
    obj.name = 'da';
}
var person = new Object();
setName(person);
console.log(person.name);
```
- instanceof 操作符
  - 如果变量是给定引用类型的实例，那么instanceof操作符就会返回true
  - 所有引用类型都是Object的实例
  ```
  const person = {
      name: 'xiao'
  }
  person instanceof Object // true
  ```

  #### 78. JavaScript 中的作用域与变量声明提升？

```
变量提升的表现是，无论我们在函数中何处位置声明的变量，好像都被提升到了函数的首部，我们可以在变量声明前访问到而不会报错。

造成变量声明提升的本质原因是 js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象。当我们访问一个变量时，我们会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。这就是会出现变量声明提升的根本原因。
```

详细资料可以参考：
[《JavaScript 深入理解之变量对象》](http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1.html)
